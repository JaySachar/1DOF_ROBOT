#include "encoder_reading.h"

void QEI1_Init (void){
    // provide a clock for QEI Module 1. It is set to PC5, PC6
    SYSCTL_RCGCQEI_R |= SYSCTL_RCGCQEI_R1;

    // Set second to last bit in 32 bit register to 1, to enable run mode clock gating control for Port C 0000.0100
    SYSCTL_RCGCGPIO_R |= SYSCTL_RCGCGPIO_R2;

    // Wait for GPIO module to be ready
    while ((SYSCTL_PRGPIO_R & SYSCTL_RCGCGPIO_R2) == 0) {};

    // Unlock GPIO Port C (if needed for configuration)
    GPIO_PORTC_LOCK_R = 0x4C4F434B; // Unlock register to allow write access
    GPIO_PORTC_CR_R |= 0x70; // Enable changes to  PC4, 5, 6 pins

    // Disable Analog Functions
    GPIO_PORTC_AMSEL_R &= 0x00;



    // Configure Port C pins 4, 5, and 6 as alternate functions (QEI)
    GPIO_PORTC_AFSEL_R |= (1 << 4) | (1 << 5) | (1 << 6); // Set pins 4, 5, 6 as alternate functions. Mode control select register. Setting a bit in this register makes the GPIO line to be controlled by an associated peripheral. Set PC4, PC5, PC6 as alternate functions.

    // Clear and set PCTL register bits for Port C pins 4, 5, and 6 to QEI function
    GPIO_PORTC_PCTL_R &= ~0x0FFF0000; // Clear PCTL register bits for PC5, PC6, PC7
    GPIO_PORTC_PCTL_R |= 0x06660000; // Configure PCTL for QEI function GPIO_PORTC_PCTL_R  |= 0x06660000; // Set Pins 4, 5, 6 equal to 0110 which is equal to 6. According to Table 23-5 (pg. 1351) the associated alternate function is IDX1, PhA1, and PhB1.

    // Disable QEI1 module for configuration
    QEI1_CTL_R &= ~QEI_CTL_ENABLE;

    // Configure QEI1 settings
    QEI1_CTL_R |= QEI_CTL_SWAP; // Swap PhA and PhB
    // QEI1_CTL_R |= QEI_CTL_SIGMODE; // Count direction as per PhA and PhB
    QEI1_CTL_R |= QEI_CTL_CAPMODE; // Quadrature mode

    NVIC_EN1_R |= 0x00000060; // Enable Interrupt #38, QEI1
    NVIC_PRI9_R = (NVIC_PRI9_R & 0xFF1FFFFF)|(5 << 21); // Move 101 21 bits to the left so its in position 23:21
    QEI1_POS_R = 0;
    QEI1_MAXPOS_R = 500*4*6.3-1; // Set maximum position to 500 - 1 pulses per revolution

    // Enable QEI1
    QEI1_CTL_R    |= QEI_CTL_ENABLE;

    GPIO_PORTC_DEN_R |= (1 << 4) | (1 << 5) | (1 << 6); // Enable digital function on PC5, PC6, PC7
    GPIO_PORTC_DIR_R &= ~0x70;
    // To read the position of the encoder, check QEIPOS QEI1_POS_R
}
float QEI1_GetMotorPosition(void){
   return QEI1_POS_R*360/(4*6.3*500); // Read the current motor position
}




/*
void PortB_Init(void){

SYSCTL_RCGCGPIO_R |= 0x00000002; // Set second to last bit in 32 bit register to 1, to enable run mode clock gating control for Port B
while ((SYSCTL_PRGPIO_R & 0x00000002) == 0) {}; // Wait for GPIO module to be ready
GPIO_PORTB_LOCK_R = 0x4C4F434B; // Lock register enables write access to GPIOCR. 0x4C4F.434B unlocks GPIOCR register
GPIO_PORTB_CR_R |= 0xFF; // CR is the Commit register. determines which bits of GPIOAFSEL, GPIOPUR, GPIOPDR, and GPIODEN registers are committed when a write to them is performed.
GPIO_PORTB_AMSEL_R = 0x00; // Only for ports and pins that can use ADC AINx inputs. If any pin is to be used for ADC input, the appripriate bit must be set to disable the analog isolation circuit.
GPIO_PORTB_PCTL_R = 0x00000000; // Sets communication protocol for a pin
GPIO_PORTB_DIR_R = 0x03; // Sets direction (input == 0, output == 1). Pin PB0 and PB1 are inputs
GPIO_PORTB_AFSEL_R = 0x00; // Mode control select register. Setting a bit in this register makes the GPIO line to be controlled by an associated peripheral.
GPIO_PORTB_PUR_R = 0x00; // Pull Up Select Register. When set, a weak pull-up resisteron the corresponding GPIO signal is enabled.
GPIO_PORTB_DEN_R = 0xFF; // GPIO Digital ENable. Setting a bit, causes that pin to be a digital input/output
                         // Just set all of Port B as a digital input / output
// Interrupts are enabled/disabled via GPIO_IM (GPIOIM Register pg. 667)
GPIO_PORTB_IM_R  &= 0x00; // Clear all IME for each Pin to make sure no accidental interrupt
GPIO_PORTB_IS_R  |= 0x03; // Set PB0 and PB1 to be edge-sensitive (0000.0011)
GPIO_PORTB_RIS_R |= 0x00; // Clear all raw interrupt statuses on all pins.
GPIO_PORTB_IM_R  |= 0x03;
GPIO_PORTB_IBE_R |= 0x03; // Set PB0 and PB1 to be triggered by both edges (rising and falling)
GPIO_PORTB_IM_R  |= 0x03; // Interrupt mask register. Setting a bit here allows interrupts that are generated by the pin to be sent to the interrupt controller
GPIO_PORTB_ICR_R |= 0x03; // Clear any Interrupts on PF4
// Port B is Vector Number 46, Interrupt Number 30
// Interrupt Number 30, so Register 36 (PRI7)
NVIC_PRI7_R =(NVIC_PRI7_R & 0xFF1EFFFF)|0x00A00000; // Bits 23:21 are set to 101 (5, middle priority),and are associated with 4n+2 (4*7+2 = 30) so interrupt 30 is set to a priority of 5
000 XXXXX 000 XXXXX 000 XXXXX 000 XXXXX // NVIOC_PRI7_R initially. We want to target bits 23:21 while preserving the reserved bits values (XXXXX)
&111 11111 000 11111 111 11111 111 11111 // Preserves all other bits, while setting bits 23:21 to 0
_________________________________
000 XXXXX 000 XXXXX 000 XXXXX 000 XXXXX
|000 00000 101 00000 000 00000 000 00000
_________________________________
000 XXXXX 101 XXXXX 000 XXXXX 000 XXXXX

// Enable interrupt for interrupt 30 (EN0)
NVIC_EN0_R = (1 << 30); // Enable interrupts for Port F (Interrupt 30)
                        // NVIC_EN0_R = 0100 0000 0000 0000 0000 0000 0000 0000 == 0x4000.0000
    }
}
*/

